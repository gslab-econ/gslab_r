% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MLEModel.R
\docType{class}
\name{MLEModel-class}
\alias{MLEModel-class}
\alias{MLEModel}
\title{A Reference Class that Provides a Template for Maximum Likelihood Estimation Models}
\description{
A Reference Class that Provides a Template for Maximum Likelihood Estimation Models
}
\section{Fields}{

\describe{
\item{\code{group_unobs_list}}{A vector of names of group-level unobservables (integrated numerically).}

\item{\code{indiv_unobs_list}}{A vector of names of individual-level unobservables (integrated numerically).}

\item{\code{error_list:}}{A vector of names of individual-level errors (not integrated numerically).}

\item{\code{error_distributions}}{A list that contains the distributions of all errors in \code{error_list}.}

\item{\code{error_dimensions}}{A list that contains the number of dimensions of each observations of
all errors in \code{error_list}.}

\item{\code{dparamlist}}{A vector of names of derived parameters.}

\item{\code{ngroup_unobs}}{The number of group-level unobservables in \code{group_unobs_list}.}

\item{\code{nindiv_unobs}}{The number of individual-level unobservables in \code{indiv_unobs_list}.}

\item{\code{nerrors}}{The number of error terms in \code{error_list}.}

\item{\code{ndparam}}{The number of derived parameters in \code{dparamlist}.}

\item{\code{dindices}}{A list that gives the index of each derived parameter.}

\item{\code{numerical_integral}}{An indicator of whether the model requires numerical integration.}
}}

\section{Methods}{

\describe{
\item{\code{computeLikelihoodByGroup(param, data, nodes, weights)}}{\subsection{Description}{
        Compute likelihood by group, integrating unobservables numerically.}

        \subsection{Parameters}{
        \code{param}: The parameters at which to calculate likelihood.

        \code{data}: An \code{MLEData} object.

        \code{nodes}: A list of nodes for all unobservables to facilitate the numerical integration.

        \code{weights}: A list of weights of each group to facilitate the numerical integration.}
        \subsection{Return}{
        A vector of likelihood with length equal to the number of groups.}}

\item{\code{computeNodesAndWeights(data, quadacc)}}{\subsection{Description}{
        Compute nodes and weights for numerical integration.

        The complexity in the code here comes from the fact that different groups may have different
        numbers of unobservables (if there are individual-level unobservables and the panel is
        unbalanced), and we need to arrange the nodes for each unobservable into a single vector to
        speed numerical integration.}
        \subsection{Parameters}{
        \code{data}: An \code{MLEData} object.

        \code{quadacc}: The accuracy.
}
        \subsection{Return}{
        \code{nodes}:

        \code{nodes$value}: A list of nodes with one field for each unobservable.

        \code{nodes$group}: A single-column matrix indexing the group variable.

        \code{nodes$nodenum}: A single-column matrix indexing the order of node within each group.

        \code{nodes$obs}: A single-column matrix indexing each observation.

        \code{weights}:

        \code{weights$wgt}: A single-column matrix representing weight for each group.

        \code{weights$group}: A single-column matrix indexing the group variable.

        \code{weights$node}: A single-column matrix indexing the order of node within each group.
        \code{data_rep}: An \code{MLEData} object with each observations replicated by the number
        of nodes depending on the number of unobservables and accuracy. The nodes for unobservables
        are added in the data. The number of groups is also multiplied by the number of nodes.}}

\item{\code{derivedParam(param, dparamname, constants)}}{\subsection{Description}{
        Compute a derived parameter.

        This method takes a vector of parameters, constants and the name of a derived parameter,
        and returns the value of the derived parameter. In \code{MLEModel}, this method simply
        returns an empty value. Implementing subclasses typically populates this method to handle
        all derived parameters listed in the \code{dparamlist} field of the model using
        \code{switch} protocol.}

        \subsection{Parameters}{
        \code{param}: A vector of parameters at which to calculate the derived parameters.

        \code{dparamname}: The name of the derived parameter.

        \code{constants}: A list of constants used to calculate the derived parameters.}

        \subsection{Return}{
        The deried parameter.}}

\item{\code{drawErrors(data, simopts)}}{\subsection{Description}{
        Draws error vectors for an \code{MLEModel} object.}

        \subsection{Parameters}{
        \code{data}: An \code{MLEData} object.

        \code{simopts}: An \code{MLESimulationOptions} object.}}

\item{\code{drawUnobservables(data, simopts)}}{\subsection{Description}{
        Draws unobservable vectors for an \code{MLEModel} object.}

        \subsection{Parameters}{
        \code{data}: An \code{MLEData} object.

        \code{simopts}: An \code{MLESimulationOptions} object.}}

\item{\code{estimate(data, estopts = NULL)}}{\subsection{Description}{
        Estimate an \code{MLEModel} by maximum Likelihood with numerical integration.}

        \subsection{Parameters}{
        \code{data}: An \code{MLEData} object.

        \code{estopt}: An \code{MLEEstimationOptions} object. If not specified, the default
        options will be used.
}
        \subsection{Return}{
        An \code{MLEEstimationOutput} object.}}

\item{\code{getDerivedParam(param, constants = NULL)}}{\subsection{Description}{
        Compute all derived parameters of the model.

        This method is a wrapper of the method \code{derivedParam}, which returns a vector
        of all derived parameters.}
        \subsection{Parameters}{
        \code{param}: A vector of parameters at which to calculate the derived parameters.

        \code{constants}: A list of constants used to calculate the derived parameters.
}
        \subsection{Return}{
        A vector of all derived parameters.}}

\item{\code{simulate(param, data, simopts = NULL)}}{\subsection{Description}{
          Simulates data from an \code{MLEModel}.}

          \subsection{Parameters}{
          \code{param}: A vector of parameters at which to simulate data.

          \code{data}: An \code{MLEData} or \code{MLESetOfDatasets} object.

          \code{simopts}: An \code{MLESimulationOptions} object. If not specified, the default
          simulation options will be used.}

          \subsection{Return}{
          If \code{simopts.replications} equal to 1 and \code{data} is not an 
          \code{MLESetOfDatasets} object: An \code{MLEData} object which include data input, as
          well as errors, unobservables and dependent variables from random draws.

          If \code{simopts.replications} is larger than 1 or \code{data} is an 
          \code{MLESetOfDatasets} object: An \code{MLESetOfDatasets} object with a list of 
          \code{MLEData} objects. Each element includes data input, as well as errors,
          unobservables and dependent variables from random draws using different seed. The seed is
          incremented between each replication.}}

\item{\code{transformErrors(param, data, raw_error)}}{\subsection{Description}{
        Transform errors in the model.

        This function takes as input a vector of parameters, an \code{MLEData} object, and a list
        of i.i.d. draws of errors, and returns a list of transformed errors. 
        In \code{MLEModel}, this method simply passes through the raw errors.
        Implementing subclasses typically transform the errors as a function of parameters and data.
        For models with no errors, this method can simply return an empty list.}

        \subsection{Parameters}{
        \code{param}: A vector of parameters at which to evaluate errors.

        \code{data}: An \code{MLEData} object

        \code{raw_error}: A list of errors with one field for each error in the model and field names 
         matching error names. The raw errors are drawn i.i.d. across observations with distributions
        defined by the \code{error_distributions} field of the model. For vector-valued errors
        (dimension > 1 as defined by the \code{error_dimensions} field of the model),
        the draws are also i.i.d. across elements of the vector.}

        \subsection{Return}{
        A list of transformed errors.}}

\item{\code{transformUnobservables(param, data, raw_unobs)}}{\subsection{Description}{
        Transform unobservables in the model. 

        This function takes as input a vector of parameters, an \code{MLEData} object, and a list
        of i.i.d. draws of unobservables, and returns a list of transformed unobservables. 
        In \code{MLEModel}, this method simply passes through the raw unobservables.
        Implementing subclasses typically transform the unobservables as a function of parameters
        and data. For models with no unobservables, this method can simply return an empty list.}

        \subsection{Parameters}{
        \code{param}: A vector of parameters at which to evaluate unobservables.

        \code{data}: An \code{MLEData} object

        \code{raw_unobs}: A list of unobservables with one field for each unobservable in the model
        and field names matching unobservables names.

        For group-level unobservables, each field of \code{raw_unobs} contains standard normal
        draws at the group level, with values replicated across draws within groups.

        For individual-level unobservables, \code{raw_unobs} contains i.i.d. standard normal
        draws across observations.

        The transformation function must not exhibit dependencies across groups, nor, in the case of
        group-level unobservables, across observations.}

        \subsection{Return}{
        A list of transformed unobservables.}}
}}

\section{Fields}{


\describe{
\item{\code{paramlist}}{A vector of parameter names.}

\item{\code{nparam}}{The number of parameters.}

\item{\code{startparam}}{A vector of starting parameter values for estimation.}

\item{\code{indices}}{A list giving the index of each parameter.}

\item{\code{lhslist}}{The names of dependent (i.e., stochastic) variables.}

\item{\code{rhslist}}{The names of independent (i.e., non-stochastic) variables.}
}
}

\section{Methods}{


\describe{
\item{\code{isValidModel()}}{A method to determine if it's a valid instantiation and should be overridden in subclasses.}

\item{\code{isValidParameterVector(param)}}{A method to determine if the parameters are valid for the model.

        \code{param}: A vector of parameters.}

\item{\code{XBeta(varlist, data, param, constant = 0, constname = "constant",
  coeff_prefix = "", coeff_suffix = "_coeff", datavar_prefix = "",
  datavar_suffix = "")}}{Return the product of data and coefficients.

        \code{varlist}: A vector of variables names.

        \code{data}: A ModelData object.

        \code{param}: A vector of coefficients. The order of the coefficients should be the same as 
        the field \code{varnames} of the \code{Model} object.

        \code{constant}: Whether the calculation includes constant or not.

        \code{constname}: The name of the constant.

        \code{coeff_prefix}: The prefix of coefficient names in the model.

        \code{coeff_suffix}: The suffix of coefficient names in the model.

        \code{datavar_prefix}: The prefix of variable names in the dataset.

        \code{datavar_suffix}: The suffix of variable names in the dataset.}
}
}

